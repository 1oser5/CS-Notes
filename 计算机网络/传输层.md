# 传输层
传输层提供了进程间的通信

## UDP和TCP的区别

### UDP
+ 无连接
+ 不可靠（尽最大努力交付）
+ 面向报文
+ 无拥塞机制
+ 支持一对一，多对多，多对一通信

### TCP
+ 面向连接
+ 可靠交付
+ 面向字节流
+ 有拥塞机制
+ 双全工通道
+ 每条TCP支持一对一

### UDP首部

![avator](../pic/计算机网络-传输层-udp.jpeg)

UDP首部只有8字节，12字节的伪首部是为了计算检验和临时添加的

### TCP首部

![avator](../pic/计算机网络-传输层-tcp.png)

+ 序号：对字节流进行编号，如果当前序号为301，如果数据长度为200，则下一个报文段的编号为 501
+ 确认号，如果 A->B 时报文段为 301，数据长度为200，则确认号为 501
+ 数据偏移：首部长度
+ 确认ACK：当AKC=0时确认字段有效，否则报文段无效。TCP规定建立连接后所有报文段ACK都置为1
+ 同步SYN：连接使用来同步序号，如果ACK=1,SYN=0表示是请求连接报文段，若双方同意连接，则ACK=1,SYN=1
+ 终止FIN：表示此报文段发送方已经发送完数据，请求释放连接

### TCP三次握手

![avator](../pic/计算机网络-传输层-tcp-三挥.png)

#### 第一次握手

CLIENT 将 ACK 置为1，随机产生一个初始序列发给 SERVER，进入 SYN_SENT 状态

#### 第二次握手

SERVER 收到 CLIENT 的 ACK=1，知道 CLIENT 请求连接，这时候会把SYN置1，ACK置1，产生一个随机序列，产生一个确认号为 CLIENT序列号+1，发给CLIENT，进入 SYN_RVCD 状态

#### 第三次握手

CLIENT 检查确认号是否为序列号+1，将ACK置1，产生一个确认号等于服务器初始序号+1，发送给服务器，进入ESTABLISHED状态，SERVER检查确认号正确和ACK=1后，也进入ESTABLISHED状态，连接建立

### TCP 三握问题

#### 为什么要第三次握手

+ 无法确认CLIENT是否收到了报文段
+ 已失效的报文段因为网络滞留延迟到达服务器，则server就会打开连接，浪费了资源

#### 第三次客户端ACK未送达，会怎么样

如果SERVER未收到ACK确认报文，则会重发 ACK+SYN，默认重发5次，之后自动关闭连接进入CLOSED状态

CLIENT如果在超时重传时再次发送数据，则SERVER确认之后建立连接，进入ESTABLISHED状态。
如果SERVER已关闭，则会以RST包应答


#### 建立连接但是客户端出现了故障

SERVER每次收到请求后就会复位一个计时器，一般是2小时，如果规定时间内CLINET没有发生数据，则SERVER会发生一个探测报文段，每隔75s发送一次，如果十次之后都没有反应，则SERVER默认CLIENT故障，关闭连接。


### TCP四次挥手
![avator](../pic/计算机网络-传输层-tcp-四挥.jpeg)

#### 第一次挥手

CLIENT 将FIN置为 1，发送一个序列号给SERVER,进入FIN_WAIT_1昨天

#### 第二次挥手
SERVER收到报文，将ACK置为1（本来也为1吧），确认号为序列号+1，进入CLOSE_WAIT状态，此CLIENT无法向SERVER发送数据，而SERVER还能发送数据

#### 第三次挥手
SERVER将FIN置为1，发送一个初始化队列，进入LAST_ACK状态

#### 第四次挥手
CLIENT将确认号设置为序列号+1，发送报文段，CLIENT进入TIME_WAIT状态，SERVER收到后进入CLOSED状态，CLIENT在2*MSL之后如果未收到SEVER报文，也进入CLOSED


### TCP 四挥问题

#### 第二次和第三次挥手能否合并

在SERVER收到CLIENT断开连接请求之后，可能还有部分数据没有发送完，这时候应该先确认收到了断开连接请求，在等数据发送完毕之后，再发FIN，因此不能合并。

#### 第二次挥手CLIENT未收到SERVER发送的ACK

CLIENT会重发FIN请求

#### CLIENT TIME_WAIT的意义

第四次挥手时，CLIENT发送给SERVER的ACK确认可能会丢失，这时候SERVER会重发FIN请求，TIME_WAIT就是用来避免这种情况，接收SERVER重发请求的。如果CLIENT在2*MSL之内为收到FIN请求，默认SERVER已收到，关闭连接。
MSL(Maximum Segment Lifetime)，指一个片段在网络中最大的存活时间，2MSL就是一个发送和一个回复所需的最大时间。


#### TCP可靠传输

TCP 使用超时重传来实现可靠传输，如果一个已经发送的报文段在超时时间内没有收到确认，就重传该报文段。

一个报文段从发送再到接收到确认所经过的时间称为往返时间 RTT，加权往返时间为 RTTs

超时时间RTO应该略大于 RTTs


### TCP滑动窗口

窗口是缓存的一部分，用来暂存字节流。发送方和接收方各有一个窗口，发送方根据这个值和其他信息来设置自己的窗口大小，而接收方通过TCP报文段中的窗口字段告诉发送方自己的窗口大小。

发送窗口内部的字节被允许发送，接受窗口内部的字节被允许接受。如果发送窗口左部已经发生并且收到确认，那么就将发送窗口右移一段距离，直到左边第一个字节不是已经发送并且确认的状态。

接收窗口的滑动类似，接受窗口只会对最后一个按序到达的字节进行曲儿，如果接收窗口收到了 {31, 34, 45} 其中31按需到达，则只会对 31 进行确认

![avator](../pic/计算机网络-传输层-TCP滑动窗口.jpeg)

### TCP 流量控制

流量控制是为了控制发送方发送速率，保证接收方来得及接受

接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送速率

#### 什么是零窗口

如果接收方没有能力接收数据，就会将接收窗口设置为0，这时候发送方必须暂停发送数据，但是会启动一个计时器，到期后自动发送一个大小为1子节的探测数据包，已查看接收窗口的状态。如果接收方能接收数据，则会在返回报文中更新接收窗口大小，恢复数据传输。

### TCP 拥塞控制

![avator](../pic/计算机网络-传输层-TCP拥塞控制.png)

拥塞控制主要有四个算法组成：**慢启动、拥塞避免、快重传、快恢复**

1.慢启动：刚开始发送数据时，会将拥塞窗口设置为最大报文段MSS的数值，每收到一个新的确认报文后，就把拥塞窗口加MSS，这样没经过一次传输轮次（或者是一个往返时间），拥塞窗口大小就会加倍

![avator](../pic/计算机网络-传输层-慢开始.png)


2.拥塞避免：当拥塞窗口的大小达到慢开始时，开始执行拥塞避免算法，拥塞窗口大小不在指数增加，而是指数增加，没经过一次传输伦次只增加1MSS。


> 无论是在慢开始阶段还是拥塞避免阶段，只要发送方判断网络出现拥塞（根据有无收到确认），就会把慢开始门限 ssthresh 设置为出现拥塞时的发送窗口的一半（但不能小于2）。然后把拥塞窗口重新设置为1，执行慢开始算法。（这里不是快重传情况）

3.快重传：快重传要求接收方在收到一个失序的报文段后就立刻发出重复确认（为了让发送方鸡早知道报文段没有到达对方）而不是等自己发送数据再捎带。如果发送方一连受到三个重复确认就应当立即重传对方未收到的报文段。

![avator](../pic/计算机网络-传输层-tcp快重传.png)

4.快恢复：当收到三个连续确认后，就把慢门限减半，然后执行拥塞避免算法。不执行慢开始算法的原因：如果网络拥塞是不会受到好几个重复确认，网络是正常的。