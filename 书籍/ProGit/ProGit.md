+ [起步](#起步)
  + [关于版本控制](#关于版本控制)
  + [本地版本控制](#本地版本控制)
  + [集中化版本控制系统](#集中化版本控制系统)
  + [Git基础](#Git基础)
  + [初次运行Git前的配置](#初次运行Git前的配置)


# 起步

## 关于版本控制

版本控制是一种记录文件相关变化，以便将来查阅的特定版本的系统。

采用版本控制可以让你有效的保存各个版本的文件。在你操作失误或者心情不好乱弄一通时，版本控制可以有效帮你“回到过去”。


### 本地版本控制

许多人习惯用复制整个项目的方式来进行本地的版本控制，这样有效，但是未免会造成版本控制混乱，取名麻烦，复制时间消耗等问题。

之后人们也开发出了用简单数据库来记录文件差异的方式。
![avator](../../pic/local-version-control.png)
其中最流行的就是 rcs，许多计算机系统还看得到它的声影。它通过某种特定的补丁文件，记录对应文件修改前后的内容变化。每次修订完之后，rcs 将不断打补丁来计算各版本的文件内容。

### 集中化版本控制系统

那要在不同的系统中，或者不同的设备中进行版本控制呢？于是集中化版本控制系统（Centralized Version Control Systems, CVCS）出现了。类似 CVS, Subversion 等，都有一个集中管理的服务器，用户通过客户端统一向该服务器下载文件或者更新文件。

![avator](../../pic/centralized-version-control.png)

这种版本控制有一定好处，每个人可以在一定程度上看到项目上其他人在干什么，而管理员也可以轻松的分配权限，管理起来比本地版本控制容易得多。

但也存在隐患，比如中心服务器宕机一个小时，那么一个小时中所有人都不能提交或者下载，是否影响效率。亦或者更严重，中心服务器数据丢失，导致整个项目无法复原，只能依靠本地存储的快照进行修复。

### 分布式版本控制系统

于是分布式版本控制系统（Distributed Version Control System, DVCS）出现了。客户端不止提取最新版本的快照，而是将整个代码仓库进行镜像。这样一来，任何协调工作的服务器故障了，都可以使用任意一台电脑的本地仓库进行恢复。

![avator](../../pic/distributed-version-control.png)

## Git基础

Git 与其他 DVCS 系统的差异

### 直接记录快照，而非差异比较

Git 只关心文件数据的整体是否发生变化，其他系统则只关心文件具体内容的差异。
![avator](../../pic/svn-diff.png)

Git 并不保存这些文件的差异数据，相对来说，Git 更像是把变化的文件快照后，记录在一个微型的文件系统中，每次提交更像后，他会总览一遍所有文件的指纹信息并对修改了的文件做一快照，然后保存执行这个快照的索引。为了提高性能，如果文件没有变化，则只保存对上一次快照的链接。

![avator](../../pic/git-diff.png)

### 几乎所有的操作都是本地执行

Git 大多才做都可以在本地执行，不需要联网。因为本地仓库存储着最新版本的代码和修改记录，你完全可以在断网的情况下查阅版本修订和修改代码，再在连上网络之后上传到远程仓库。


### 时刻保持数据的完整性

保存到 Git 之前，所有数据都要进行内容的校验和（checksum），并将此结果作为数据的唯一标识和索引。

Git 使用 SHA-1 算法计算数据的校验和，通过对文件的内容或目录的结构计算出一个 SHA-1 哈希值，作为指纹字符串，该字符由 40 个 16 进制字符串组成，看上去像：
```
24b9da6552252987aa493b52f8696cd6d3b00373
```

事实上在 Git 数据库中都是用此哈希值来进行索引的，而不是文件名。

### 多数操作仅添加数据

Git 的大多数操作都只是在 Git 数据库中添加数据，因为多数的不可逆操作都会时重现历史版本变得困难重重。

### 文件的三种状态

对任何一个文件，在 Git 中只有三种状态，已提交（committed），已修改（modified），以暂存（staged）。

+ 已提交（committed）: 文件已经保存到本地仓库中。
+ 已修改（modified）: 文件被修改但还未提交保存。
+ 已暂存（staged）: 文件被放在下次提交要保存的清单中。

Git 保存文件的三个工作区域： Git 的工作目录，暂存目录，本地仓库。

![avator](../../pic/work.png)

每个项目都有一个 Git 目录（如果是 git clone 则 .git 是 Git 目录，如果是 git clone --bare，新建目录本身急速 Git 目录）。Git 目录用来保存元数据和对象数据库。该目录非常重要，每次克隆镜像仓库其实都是克隆该目录中的数据。

从项目中取出某个版本的所有文件和目录，用来后续工作的就是工作目录。这些文件实际上都是从 Git 目录中读取出来的。

暂存区只是一个存放在 Git 目录中的文件（Index 文件）

基本 Git 工作流程：

+ 在工作目录修改文件。
+ 对修改文件进行快照，保存到暂存区域。
+ 提交更新，将暂存区域的文件快照转储到 Git 目录中。

## 初次运行Git前的配置

Git 提供了一个叫 git config 的工具来管理相应的工作环境变量。正是这些环境变量，决定了 Git 在各个环节的行为和工作方式，变量可以存储在以下三个地方：

+ /etc/gitconfig 文件：系统中对所有用户普遍适用的配置，如果使用 git config --system 读取的就是该文件。
+ 