# Gzip格式和DEFLATE压缩算法

> 原文地址 https://luyuhuang.github.io/2020/04/28/gzip-and-deflate.html

当你输入 `tar -zcf src.tar.gz src`时，就可以将目标目录下的所有文件打包成一个 tar.gz 格式的压缩包。在这里 `tar`指归档格式，将多个文件压缩为一个文件。 `gz` 值使用 gzip 的压缩格式，其使用 DEFLATE 算法压缩得到。

这篇文章介绍了 DEFLATE 算法，DEFLATE 算法结合了 LZ77 算法和 Huffman 编码。


## LZ77 算法

J. Ziv 和 A. Lempel 在 1977 发表了一篇名为 `A Universal Algorithm for Sequential Data Compression` 的论文, 提出了一种**顺序数据的通用压缩算法**. 这个算法后来被称为 LZ77 算法. 事实上 DEFLATE 算法使用的 LZ77 跟原版有所不同, 这里我们以 DEFLATE 中的为准。


### 基本原理

我们平常使用的文件总会有许多重复部分，LZ77压缩算法正是利用了这一特点，它会尽可能的在文件中中找出重复的内容，然后用一个标记替代重复内容。这个标记可用明确指出这部分在哪里出现，以 葛底斯堡演说 的第一段为例:
> Four score and seven years ago our fathers brought forth, on this continent, a new nation, conceived in Liberty, and dedicated to the proposition that all men are created equal.
我们规定，只要有两个以上的字符与前文重复，就可以使用重复标记 `<d, l>` 代替它，`<d, l>` 表示这个位置的字符串等价于 `d` 个字符串前，长度为 `l` 的字符串。上述内容可表示为:
> Four score and seven years ago <30,4>fathe<16,3>brought forth, on this continent, a new nation,<25,4>ceived in Liberty<36,3><102,3>dedicat<26,3>to<69,3>e proposi<56,4><85,3>at all m<138,3>a<152,3>cre<44,5>equal.

你看会发现压缩后居然比没压缩还长😂，这只是一个简单演示，之后会有更详细说明。

这个算法最简单的实现就是遍历字符串，通过在前文查找是否有重复字符求出最长子串，其复杂度为 `O(n*2)`。在处理大文件的时候效率很低。

### 使用哈希表

由于查找很慢，我们可以用哈希表吧一个长度为三的字符串映射为一个列表，包含了这个字符串曾出现过的所有位置，压缩时从头到尾扫描字符串。假设接下来三个字符为 `abc`，首先会检查字符串 `abc` 是否在哈希表中，如果不在，则原样输出字符 `a`并移动到下个字符。如果存在，则把当前字符开始的字符串与所有以 `abc` 开始的字符串比较，寻找到一个长度为 N 的最长匹配并输出重复标记。然后向后移动 N 个字符。无论是否找到匹配，都会把当前位置的三个字符插入到哈希表中。

当字符串为 `abcabcdabcde` 时，算法分以下几步：

1. 扫描第0个字符串，哈希表为空，原样输出字符串 `a`，将 `abc` 插入哈希表。
```python
hash table: {}
 abcabcdabcde
 ^
 output: a
```

2. 扫描到第三个字符 `a`，哈希表表示 `abc` 在 0 处出现过，最长匹配就为 `abc`，因此输出 `<3, 3>`，同时把当前位置插入到映射表中。
```python
 hash table: {"abc":[0],"bca":[1],"cab":[2]}
 abcabcdabcde
    ^
 output: abc<3,3>
```

3. 扫码到第7个字符 `a`，哈希表指示 `abc` 在 `0`, `3` 处出现过，依次与当前位置匹配， `0` 处只能匹配到 `abc`，而`3`处能匹配到 `abcd`，所以输出 `<4, 4>`，同时把当前位置插入哈希表

### 滑动窗口
有了哈希表，在文件过长时仍有效率问题，为此我们使用滑动窗口，仅在窗口中查找重复内容，窗口长度一般为 32 kb。


### 惰性匹配

有时候这种策略并不是最优解，原因是后文中可能出现更长的匹配字符串。因此 DELATE 采用一种叫做 惰性匹配的优化策略。每当算法找到一个长度为 N 的匹配后，就会试图在下一个字符串寻找更长的匹配，只有当没找到更长的匹配是，才为当期匹配输出重复标记，否则使用更长匹配，惰性匹配可以连续触发，如果一次惰性匹配发现了更长的匹配，则会继续。

惰性匹配能提高压缩率，但是会让压缩变慢。可以通过运行参数来设置是否开始惰性匹配。



## Huffman编码
这部分我处理了Huffman原理部分看懂了，别的都没懂……就不班门弄斧了。


## Gzip格式

Gzip格式由头部信息,压缩主题和尾部信息组成,头部包括了文件基本信息,时间,压缩方法等。尾部则包含校验和与原始大小，这些信息与压缩算法无关，这里不赘述了。


压缩主题由一个或者多个区块组成，每个区块的长度不固定，都有自己的压缩和编码方式。区块可能起始或者结束与任何一个比特，不必对齐字节，需要说明的是，重复标记指示的距离有可能是跨区块的。

上文阐述的都是使用动态 Huffman 编码压缩，事实上有一个区块还可能使用静态 Huffman 编码压缩或者不压缩。

所有区块都以一个三位的头部开始，包含以下数据：
||||
| :--: | :--:| :--:|
|name|length|description|
|BFINAL	|1 位| 标识是否是最后一个区块|
|BTYPE|2 位| 标识类型. 00: 未压缩; 01: 静态 Huffman 编码压缩; 10: 动态 Huffman 编码压缩; 11: 保留|

### 未压缩区块

未压缩区块包含以下数据
||||
| :--: | :--:| :--:|
|name|length|description|
|LEN	|2 位| 区块数据长度|
|NLEN|2 位| LEN 的补码|
|DATA	|LEN 字节|有效数据|

### 压缩区块
||||
| :--: | :--:| :--:|
name| 	length| 	description|
HLIT| 	5 位| 	长度/字符编码的最大值减 257. 因为并不是所有的长度编码都被使用, 因此这里标记最大的长度/字符编码(长度与普通字符共用同一编码空间).|
HDIST| 	5 位| 	距离编码最大值减 1. 原理同上.|
HCLEN| 	4 位| 	3.2.3 节中的 k 减 4. 标识使用了神秘数组中的前几个编码.|
编码后的长度序列的 Huffman 编码表| 	(HCLEN + 4) * 3 位| 	如 3.2.3 节所述的 "k 个数字". 因为长度序列编码只有 19 个, 因此每个数字 3 位就够了.|
长度/字符编码的 Huffman 编码表| 	变长| 	根据上述 Huffman 编码表编码的长度序列, 用于表示长度/字符编码的 Huffman 编码表.|
距离编码的 Huffman 编码表	| 变长| 	根据上述 Huffman 编码表编码的长度序列, 用于表示距离编码的 Huffman 编码表.|
DATA| 	变长	| 有效压缩数据|
256 结束标记| 	变长| 	标识区块的结束|