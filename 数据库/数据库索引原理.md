# 数据库索引原理
本文分三个部分

第一部分主要从数据结构及算法理论层面讨论MySQL数据库索引的数理基础。

第二部分结合MySQL数据库中MyISAM和InnoDB数据存储引擎中索引的架构实现讨论聚集索引、非聚集索引及覆盖索引等话题。

第三部分根据上面的理论基础，讨论MySQL中高性能使用索引的策略。

## 索引的本质

MySQL 官方对索引的定义为: 索引(Index)就是帮助 MySQL 高效获取数据的数据结构。

在普通数据之外，MySQL 还维护这满足特定算法查找的数据结构，这些数据结构以某种方式引用数据，这样就可以在这些数据结构上实现高级查找算法，这种数据结构，就是索引

下图是一个简单搜索二叉树

![avator](../pic/数据库-索引-二叉树.png)

真实的数据库几乎没有使用二叉树或者红黑树实现索引，这只是一个例子

## B- Tree和B+ Tree

大部分数据库以及文件系统使用B- Tree 或者 B+ Tree 来作为索引结构

### B- Tree

为了描述B树，我们定义一条数据记录为一个二元组（key, data）。 key为记录的键值，而data为除了key之外的数据，B树满足以下条件：
+ d 为大于1的数，称为B树的度（一个节点含有字数的个数）
+ h为树高
+ 每个非叶子节点有n-1个key和n个指针组成，其中d<=n<=2d
+ 每个叶子结点至少包含以一个key和俩个指针，最多包含2d-1个key和2d个指针，叶节点指针为null
+ 所有叶节点具有相同的深度，等于树高h
+ key和指针互相间隔，节点两端是指针
+ 一个节点中的key从左到右非递减排列
+ 如果某个指针在节点node最左边且不为null，则其指向节点的所有key小于v(key1)，其中v(key1)为node的第一个key的值
+ 如果某个指针在节点node最右边且不为null，则其指向节点的所有key大于v(keym)，其中v(keym)为node的最后一个key的值
+ 如果某个指针在节点node的左右相邻key分别是keyi和keyi+1且不为null，则其指向节点的所有key小于v(keyi+1)且大于v(keyi)。

下面是一个d=2的B-Tree示意图

![avator](../pic/数据库-索引-B树.png)

B树是一个非常有效率的索引数据结构，假设一个度为d的B树，设其索引N个key，则其树高h的上限为logd((N+1)/2)，检索一个key，其查找节点个数的渐进复杂度为O(logdN)。

在插入一个新数据时，会破坏原树的结构，因此在插入删除时，需要对树进行一系列操作。

### B+ Tree
B+ Tree 是 B- 树的变种，与B树相比:
+ 每个节点的指针上限为2d而不是2d+1
+ 内节点不存储data，只存储key；叶子节点不存储指针

下图是一个B+树示意

![avator](../pic/数据库-索引-b+树.png)

一般来说B+树比B-树更适合外存储索引结构，具体原因与外存储器原理和计算机存储原理有关。


### 带顺序访问指针的B+ Tree

一般数据库和文件系统使用的B+ Tree 都会在经典 B+ Tree 的基础上进行优化,增加了顺序访问指针。

![avator](../pic/数据库-索引-better-b+树.png)

该优化是为了提高区间访问的性能，只需顺着节点和指针顺序遍历就可以一次性访问所有数据节点，提高了区间查询效率。

### 为什么使用B+ Tree

一般来说，索引本身也很大，所有不可能全部存储在内存中，索引往往以索引文件的形式存储在磁盘上。这样的话，在索引查找中就要产生磁盘I/O消耗。相比于内存读取，磁盘读取消耗时间要高好几个数量级，所有判断一个数据结构是否适合索引的最重要指标就是查找过程中磁盘I/O的存取次数。

主存存取原理和磁盘读取原理就不赘述了。这里提一个我之前没看到过的点

#### 局部性原理和磁盘预读

由于存储介质的特性，磁盘本身存取就比储存慢很多，再加上机械运动的耗费，一般来说磁盘的存取速度往往是主存的几百分分之一，因此为了提高效率，要尽量减少词牌I/O、为了达到这个目的，磁盘往往不是严格按需读取，而是每次都会预读，即使只需要一个字节，磁盘也会从这个位置开始，顺序向后读取一定长度的数据放入内存。这样做的依据是计算机中的著名局部性定理：

当一个程序被用到时，其附近的数据也会被马上使用

由于磁盘顺序读取效率高（不需要寻道），因此对于局部性程序来说，预读提高了I/O效率。

预读大小一般为 page 的整数倍
