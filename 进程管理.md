+ [进程与线程](#1)
  + [1.进程](#1.1)
  + [2.线程](#1.2)
  + [3.区别](#1.3)
+ [进程状态的切换](#2)
+ [进程调度算法](#3)
  + [1.批处理系统](#3.1)
  + [2.交互式系统](#3.2)
  + [3.实时系统](#3.3)
+ [进程同步](#4)
  + [1.临界区](#4.1)
  + [2.同步与互斥](#4.2)
  + [3.信号量](#4.3)
  + [4.管程](#4.4)
+ [经典同步问题](#5)
  + [1.读者-写者问题](#5.1)
  + [2.读者-写者问题](#5.2)
+ [进程通信](#6)
  + [1.管道](#6.1)
  + [2.FIFO](#6.2)
  + [3.消息队列](#6.3)
  + [4.信号量](#6.4)
  + [5.共享存储](#6.5)
  + [6.套接字](#6.6)
  
# 进程与线程 <span id = "1"></span>
## 1.进程<span id = "1.1"></span>
进程是资源分配的基本单位。

进程控制块（Process Control Block,PCB)描述进程的基本信息和运行状态，所谓的创建进程和撤销进程，都是指对 PCB 的操作。

下图显示了四个程序创建了四个进程，这四个进程可以进行并发地执行。

![avatar](pic/a6ac2b08-3861-4e85-baa8-382287bfee9f.png)

## 2.线程 <span id = "1.2"></span>
线程是独立调度的基本单位。

一个进程中可以有多个线程，他们共享进程资源。

QQ 和浏览器是两个进程，浏览器里面有很多线程，例如 HTTP 请求线程、事件响应线程、渲染线程等待，线程的并发执行使得在浏览器中点击一个新链接从而发起 HTTP 请求时，浏览器还可以响应用户的其他事件。

![avatar](pic/3cd630ea-017c-488d-ad1d-732b4efeddf5.png)

## 3.区别<span id = "1.3"></span>
1.拥有资源

进程是资源分配的基本单位，线程不用有资源，线程可以访问隶属进程的资源。

2.调度

线程是独立调度的基本单位，在同一进程中，线程的切换不会引起进程的切换，从一个进程中的线程切换到另一个进程中的线程时，会引起进程切换。

3.系统开销

由于创建或撤销进程时，系统都要位为之分配或回收资源，如内存空间、I/O 设备等，所付出的开销远大于创建或撤销线程时的开销。类似地，在进行进程切换的时候，涉及当前执行进程 CPU 环境的保存及新调度 CPU 环境的设置，而线程切换时只需保存和设置少量寄存器内容，开销很小。

4.通信方面

线程间可以通过直接读写同一进程的数据进行通信，但是进程通信需要借助 IPC。

# 进程状态的切换<span id = "2"></span>

![avatar](pic/ProcessState.png)

+ 就绪状态（ready）：等待被调度
+ 运行状态 （running）
+ 阻塞状态（waiting）：等待资源
  
应注意以下内容：

+ 只有就绪态和运行态可以相互转换，其他的都是单向转换。就绪状态的进程通过调度算法从而获得 CPU 时间，转为运行状态；而运行状态的进程，再分配给他的 CPU 时间片用完之后就会转为就绪态，等待下次调度。
+ 阻塞状态是缺少需要的资源从而由运行状态转换而来的，但是该资源不包括 CPU 时间，缺少 CPU 时间会从运行态转换为就绪态。
  
# 进程调度算法<span id = "3"></span>
不同环境的调度算法目标不同，因此需要针对不同环境来讨论调度算法。
## 1.批处理系统<span id = "3.1"></span>
批处理系统没有太多的用户操作，在该系统中，调度算法目标是保证吞吐量和周转时间（从提交到终止的时间）。

**1.1 先来先服务 first-come first-server（FCFS）**

非抢占式的调度算法，按照请求的顺序进行调度。

有利于长时间作业，不利于短作业，因为短作业必须一直等待前面的长作业执行完毕才能执行，而长作业有需要执行很长的时间，造成了短作业的等待时间过长。

**1.2 短作业优先 shortest job first（SJF）**

非抢占式的调度算法，按估计运行时间最短的顺序进行调度。

长作业可能会饿死，处于一直等待短作业执行完毕的状态。如果一直有短作业到来，那么长作业永远得不到调度。

**1.3 最短剩余时间优先 shortest remaining time next（SRTN）**

最短作业优先的抢占式版本，按照剩余运行时间的顺序进行调度。当一个新的作业到达时，其整个运行时间与当前进程的剩余时间进行比较。如果新的进程需要的时间更少，则挂起当前进程，运行新的进程。否则新的进程等待。

## 2.交互系统<span id = "3.2"></span>
交互式系统有大量的用户交互操作，在该系统中调度算法的目的是快递地进行响应。

**2.1 时间片轮转**

当所有就绪进程按 FCFS 的原则排成一个队列，每次调度时，把 CPU 时间分配给队首进程，该进程可以执行一个时间片。当时间片用完时，由计时器发出时钟中断，调度程序便停止该进程的执行，并将它送往就绪队列的末尾，同时继续把 CPU 时间分配给队首的进程。

时间片轮转算法的效率和时间片的大小有很大关系：
+ 因为进程切换需要保存信息并且载入新进程的信息，如果时间片太小，会导致进程切换的太频繁，再进程切换上就会花过多的时间。
+ 而如果时间片太长，那么实时性就不能得到保障。

  ![avatar](pic/8c662999-c16c-481c-9f40-1fdba5bc9167.png)

**2.2 优先级调度**

为每个进程分配一个优先级，按优先级进行调度。
为了防止优先级低的进程永远得不到调度，可以随着时间推移增加等待进程的优先级。

**2.3 多级反馈队列**

一个进程需要执行 100 个时间片，如果采用时间片轮转调度算法，那么需要交换 100 次。

多级队列是为这种需要连续执行多个时间片的进程考虑，他设置了多个队列，每个队列的时间片大小都不同，例如 1，2，4，8。队列在第一个进程还未执行完，就会被移到下一个队列。这种方式，之前的进程只需要交换 7 次。

每个队列优先级权也不同，最上面的优先级最高。因此只有上一个队列没有进程在排队，才能调度当前队列上的进程。

可以将这种调度算法看做是时间片轮转调度算法和优先级调度算法的结合。

![avatar](pic/042cf928-3c8e-4815-ae9c-f2780202c68f.png)

## 3.实时系统<span id = "3.3"></span>

实时系统要求一个请求在一个确定时间内得到响应。

分为硬实时和软实时，前者必须满足绝对的截止时间，后者可以容忍一定时间的超时。

# 进程同步<span id = "4"></span>
## 1.临界区 <span id = "4.1"></span>
对临界资源进行访问的那段代码称为临界区。

为了互斥访问临界资源，在每个进程进入临界区之前，都需要先进行检查。

## 2.同步与互斥 <span id = "4.2"></span>
+ 同步： 多个进程因为合作关系产生的直接制约关系，使得进程有一定的先后执行关系。
+ 互斥：多个进程在同一时刻只有一个进程能进入临界区。
  
## 3.信号量 <span id = "4.3"></span>
信号量（Semaphore）是一个整形变量，可以对其进行 down 和 up 操作，也就是常见的 P 和 V 操作。

+ **down**：如果信号量大于 0， 执行 -1 操作；如果信号量等于 0，进行进程休眠，等到信号量大于 0。
+ **up**：对信号量执行 +1 操作，唤醒睡眠的进程让其完成 down 操作。
  
down 和 up 操作需要被设计成原语，不可分割，通常的做法是在执行这些操作的时候屏蔽中断。

如果信号量的值只能为 0 或者 1，那么就成了 **互斥量（Mutex）**，0 表示临界区已经加锁，1 表示临界区解锁。

**使用信号量实现生产者-消费者问题**

问题描述：使用一个缓存区来保存物品，只有缓存区没有满，生产者才可以放入物品；只有缓存区不为空，消费者才能拿走物品。

因为缓存区属于临界资源，需要一个互斥量来控制访问。

为了同步于生产者和消费者的行为，需要记录缓冲区中物品的数量。数量可以使用信号量来计数，这里需要使用两个信号量：empty 记录空缓冲区数量， full 记录满缓存区数量。其中 empty 信号量是在生产者进程中使用，当 empty 不为 0 时，生产者才能放入物品； full 信号量是在消费者进程使用，当 full 信号量不为 0 时，消费者才可以取走物品。

注意，不能先对缓存区进行加锁，在测试信号量。也就是说，不能先执行 down（mutex）再在执行 down（empty）。如果怎么做，可能会出现这种情况：生产者对缓存区加锁后，执行 down（empty）操作，发现 empty = 0，此时生产者休眠。消费者不能进入临界区，因为生产者对缓存区加锁了，消费者无法执行 up（empty） 操作，empty 永远为 0，导致生产者永远等待，不会释放锁，消费者因此也永远等待。

```python
semaphore, empty, mutex, full = 100, 100, 1, 0
def producer():
    item = produce_item()
    down(empty) #查看空缓存区
    down(mutex) #对缓存区加锁
    insert_item(item) #加入物品
    up(mutex) #缓存区解锁
    up(full) #修改缓存区状态
def consumer():
    down(full) #检查满缓存区
    down(mutex) #加锁
    remove_item()#拿出物品
    up(mutex) #解锁
    up(empty) #清空缓存区
```

## 4.管程 <span id = "4.4"></span>
使用信号量机制实现的生产者消费者问题需要客户端代码做很多控制，而管程则把控制的代码独立出来，不仅不容易出错，也使得客户端更容易调用。

管程有一个重要特性：在一个时刻只能有一个进程使用管程。进程在无法进行执行的时候不能一直占用管程，否则其他进程永远不能使用管程。

管程引入了**条件变量**以及相关操作：**wait（）**和 **signal（）**来实现同步操作。对条件变量执行 wait（）操作会导致调用进程阻塞，把管程让出来给另一个进程持有。 signal（）操作用来唤醒被阻塞的进程

```python
class ProduceConsumer():
    def __init__(self):
        self.empty = 100
        self.full = 0
        self.count = 0
    def insert(self, item):
        #count == 0 执行插入
        if count == N:
            wait(full) #阻塞消费者进程
            insert_item(item)
            count += 1
        if count == 1:
            signal(empty)
    def remove(self):
        if count == 0:
            wait(empty)
            remove_item()
            count -= 1
            if count = N - 1:
                signal(full)

```

感觉怪怪的

# 经典同步问题 <span id = "5"></span>

## 1.读者-写者问题<span id = "5.1"></span>
允许多个进程同时对数据进行读操作，但是不允许读和写以及写和写操作同时发生。

一个整形变量 count 用来记录对数据进行读操作的进程数量，一个互斥量 count_mutex 用于对 count 加锁，一个互斥量 data_mutex 用于对读写的数据加锁。

```python
count, count_mutex, data_mutex = 0, 1, 1
#读者
def reader():
    while True:
        down(count_mutex)
        count+=1
        #第一个读者需要对数据进行加锁，放置写进程访问
        if count == 1:
            down(data_mutex)
        #锁进程之后可以释放计数数据
        up(count_mutex)
        read()
        #读取结束，因为要减少count数，先锁住该数据
        down(count_mutex)
        count -= 1
        #如果是最后一个进程，释放数据锁
        if count == 0:
            up(data_mutex)
#写者
def writer():
    while True:
        down(data_mutex)
        write()
        up(data_mutex)
```


这种写法会导致写者饿死。

## 2.哲学家进餐问题<span id = "5.2"></span>
五个哲学家围着一张圆桌，每个哲学家面前放着食物。哲学家的生活有两种交替活动：吃饭以及思考。当一个哲学家吃饭时，需要先拿起自己左右两边的筷子，并且一次只能拿起一根。

![avatar](pic/a9077f06-7584-4f2b-8c20-3a8e46928820.jpg)

为了防止死锁的发生，可设置两个条件：

+ 必须同时拿起左右两根筷子。
+ 只有在两个邻居都没有进食的情况下才允许进餐。

```python
num, THINKING, HUNGRY, EATING = 5, 0, 1, 2
state= [THINKING]*5 #哲学家状态
s = [] * 5 #哲学家信号量
left = (i + N - 1)% N #左邻居
right = (i + 1)% N #右邻居
def philosopher(i):
    while True:
        think()
        take_two(i)
        eat()
        put_two()

def take_two(i):
    down(mutex) #锁进程
    state[i] = HUNGRY
    test(i) #尝试拿筷子
    up(mutex) #释放进程
    down(s[i]) #锁住该哲学家

def put_two(i):
    down(mutex) #锁进程
    state[i] = THINKING
    test(left)
    test(right)
    up(mutex) #释放线程

def test(i):
    if state[i] == HUNGRY and state[left] != EATING and state[right] != EATING :
    state[i] = EATING
    up(s[i])
```


# 进程通信 <span id = "6"></span>

进程同步和进程通信很容易混淆，他们的区别在于：
+ 进程同步：控制多个进程按一定顺序进行。
+ 进程通信：进程间传输信息。
  
进程通信是一种手段，而进程同步是一种目的。也可以说，为了达到进程同步，需要让进程进行通信，传输一些进程同步所需要的信息。


## 1.管道 <span id = "6.1"></span>

管道是通过调用 pipe 函数创建的， fd[0]用于读，fd[1]用于写。

其具有以下限制：
+ 只支持半双工通信（单向交替传输）
+ 只能父子进程或者兄弟进程中使用
  
![avatar](pic/53cd9ade-b0a6-4399-b4de-7f1fbd06cdfb.png)

## 2.FIFO <span id = "6.2"></span>

也称为命名管道，去除了管道只能在父子进程中使用的限制。

FIFO 常用于客户-服务器应用程序中，FIFO 用作汇聚点，在客户进程和服务器进程之间传输数据。

![avatar](pic/2ac50b81-d92a-4401-b9ec-f2113ecc3076.png)

## 3.消息队列 <span id = "6.3"></span>

相比于 FIFO，消息队列具有以下优点：
+ 消息队列可以独立于读写进程存在，从而避免了 FIFO 中同步管道的打开和关闭时可能产生的困难；
+ 避免了 FIFO 的同步阻塞问题，不需要进程自己提供同步方法；
+ 读进程可以根据消息类型有选择地接受信息，而不像 FIFO 那样只能默默接受。
  
## 4.信号量 <span id = "6.4"></span> 

他是一个计数器，用于为多哥进程提供对共享数据对象的访问。

## 5.共享存储 <span id = "6.5"></span> 

允许多个进程共享一个给定的存储区。因为数据不需要在进程间复制，所以这是最快的一种 IPC。

需要使用信号量来同步对共享存储的访问。

多个进程可以将同一文件映射到它们的地址空间从而实现共享内存。另外 XSI 共享内存不是使用文件，而是使用内存的匿名段。

## 6.套接字 <span id = "6.6"></span> 
与其他通讯机制不同，它可用于不同机器间的进程通信。